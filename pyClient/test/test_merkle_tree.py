# Copyright (c) 2015-2019 Clearmatics Technologies Ltd
#
# SPDX-License-Identifier: LGPL-3.0+


from zeth.merkle_tree import MerkleTree, PersistentMerkleTree, ZERO_ENTRY
from os.path import exists, join
from os import makedirs
from shutil import rmtree
from unittest import TestCase

MERKLE_TREE_TEST_DIR = "_merkle_tests"
MERKLE_TREE_TEST_DEPTH = 4
MERKLE_TREE_TEST_NUM_LEAVES = pow(2, MERKLE_TREE_TEST_DEPTH)


class TestMerkleTree(TestCase):

    @staticmethod
    def setUpClass() -> None:
        TestMerkleTree.tearDownClass()
        makedirs(MERKLE_TREE_TEST_DIR)

    @staticmethod
    def tearDownClass() -> None:
        if exists(MERKLE_TREE_TEST_DIR):
            print(f"Removing test dir: {MERKLE_TREE_TEST_DIR}")
            rmtree(MERKLE_TREE_TEST_DIR)

    @staticmethod
    def _test_vector_to_bytes32(value: int) -> bytes:
        return value.to_bytes(32, byteorder='big')

    def _expected_empty(self) -> bytes:
        self.assertEqual(16, MERKLE_TREE_TEST_NUM_LEAVES)
        # Test vector generated by test_mimc.py
        return self._test_vector_to_bytes32(
            1792447880902456454889084480864374954299744757125100424674028184042059183092)  # noqa

    def test_combine(self) -> None:
        # Use test vectors used to test the MiMC contract (generated in
        # test_mimc.py)

        left = self._test_vector_to_bytes32(
            3703141493535563179657531719960160174296085208671919316200479060314459804651)  # noqa
        right = self._test_vector_to_bytes32(
            15683951496311901749339509118960676303290224812129752890706581988986633412003)  # noqa
        expect = self._test_vector_to_bytes32(
            16797922449555994684063104214233396200599693715764605878168345782964540311877)  # noqa

        result = MerkleTree.combine(left, right)
        self.assertEqual(expect, result)

    def test_empty(self) -> None:
        mktree = MerkleTree.empty_with_size(MERKLE_TREE_TEST_NUM_LEAVES)
        root = mktree.compute_root()
        num_entries = mktree.get_num_entries()

        self.assertEqual(0, num_entries)
        self.assertEqual(self._expected_empty(), root)

    def test_empty_save_load(self) -> None:
        mktree_file = join(MERKLE_TREE_TEST_DIR, "empty_save_load")
        mktree = PersistentMerkleTree.open(
            mktree_file, MERKLE_TREE_TEST_NUM_LEAVES)
        mktree.save()

        mktree = PersistentMerkleTree.open(
            mktree_file, MERKLE_TREE_TEST_NUM_LEAVES)
        root = mktree.compute_root()
        mktree.save()

        self.assertEqual(self._expected_empty(), root)

    def test_single_entry(self) -> None:
        mktree_file = join(MERKLE_TREE_TEST_DIR, "single")
        data = bytes.fromhex("aabbccdd")

        mktree = PersistentMerkleTree.open(
            mktree_file, MERKLE_TREE_TEST_NUM_LEAVES)
        mktree.set_entry(0, data)
        self.assertEqual(1, mktree.get_num_entries())
        self.assertEqual(data, mktree.get_entry(0))
        self.assertEqual(ZERO_ENTRY, mktree.get_entry(1))
        root_1 = mktree.compute_root()
        self.assertNotEqual(self._expected_empty(), root_1)
        mktree.save()

        mktree = PersistentMerkleTree.open(
            mktree_file, MERKLE_TREE_TEST_NUM_LEAVES)
        self.assertEqual(1, mktree.get_num_entries())
        self.assertEqual(data, mktree.get_entry(0))
        self.assertEqual(ZERO_ENTRY, mktree.get_entry(1))
        root_2 = mktree.compute_root()
        self.assertEqual(root_1, root_2)

    def test_single_entry_all_nodes(self) -> None:
        mktree = MerkleTree.empty_with_size(MERKLE_TREE_TEST_NUM_LEAVES)
        data = bytes.fromhex("aabbccdd")
        mktree.set_entry(0, data)

        nodes = mktree.compute_tree_values()

        def layer_size(layer: int) -> int:
            return int(MERKLE_TREE_TEST_NUM_LEAVES / pow(2, layer))

        def layer_start_index(layer: int) -> int:
            return layer_size(layer) - 1

        # Check layer 0
        prev_layer_start = layer_start_index(0)
        self.assertEqual(data, nodes[prev_layer_start])
        for i in range(1, MERKLE_TREE_TEST_NUM_LEAVES):
            print(f"Checking Layer 0, Node {i}, INDEX {prev_layer_start + i}")
            self.assertEqual(
                ZERO_ENTRY, nodes[prev_layer_start + i],
                f"Layer 0, node {i}")

        # Check layer `layer`
        for layer in range(1, MERKLE_TREE_TEST_DEPTH):
            layer_start = layer_start_index(layer)
            for i in range(layer_size(layer)):
                print(
                    f"Checking Layer {layer}, Node {i}, "
                    f"IDX {prev_layer_start + i}")
                self.assertEqual(
                    MerkleTree.combine(
                        nodes[prev_layer_start + 2*i],
                        nodes[prev_layer_start + 2*i + 1]),
                    nodes[layer_start + i],
                    f"Layer {layer}, node {i}")
            prev_layer_start = layer_start

        self.assertEqual(mktree.compute_root(), nodes[0])
