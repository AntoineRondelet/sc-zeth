#include <iostream>
#include <cstdio>
#include <string>

#include <grpc/grpc.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>
#include <grpcpp/server_context.h>
#include <grpcpp/security/server_credentials.h>

// Necessary header to parse the data
#include <libsnark/common/data_structures/merkle_tree.hpp>

// Include zeth headers
#include "libsnark_helpers/libsnark_helpers.hpp"
#include "circuits/computation.hpp"
#include "circuits/sha256/sha256_ethereum.hpp"
#include "circuit-wrapper.hpp"
//#include "zethConfig.h"

#include "util.hpp"

// Include the file generated by gRPC
#include "prover.grpc.pb.h"

using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::ServerReader;
using grpc::ServerReaderWriter;
using grpc::ServerWriter;
using grpc::Status;
using grpc::StatusCode;

// Use the Prover service defined in the proto file
using proverpkg::Prover;

// Use the messages defined in the proto file
using proverpkg::EmptyMessage;
using proverpkg::PackedDigest;
using proverpkg::ProofInputs;
//using proverpkg::ProofPublicInputs;
using proverpkg::HexadecimalPointBaseGroup1Affine;
using proverpkg::HexadecimalPointBaseGroup2Affine;
using proverpkg::ExtendedProof;

typedef libff::default_ec_pp ppT;
typedef libff::Fr<ppT> FieldT;
typedef sha256_ethereum<FieldT> HashT;

// Note, these denote the number of INs and OUTs of the JS
// For now this is handled by global consts, but we can easily
// think about fancier things, where the server has some config attributes
// that could be changed via a call to a rcp function like:
// `rpc ConfigProver(ConfigMsg) returns (RespMsg) {}`
// This function could change the config of the server that could thee re-run a
// setup for the new config to gen proofs for the new circuit
//
// We could go even futher and keep the setups of the diff config in a folder
// (a sort of a setup cache)
// to prevent the server from running setups for configs it has already seen
//
// No matter whether this would be a good feature or not, this is out of scope
// for this PoC
const size_t JSIns = 1;
const size_t JSOut = 1;

libsnark::merkle_authentication_node ParseMerkleNode(std::string mk_node) {
  return libff::bit_vector(libzeth::hexadecimal_digest_to_binary_vector(mk_node));
}

libzeth::ZethNote ParseZethNote(const proverpkg::ZethNote& note) {
  std::cout << "[ParseZethNote] Debug 1" << std::endl;
  std::cout << "[ParseZethNote] Debug NoteAPK" << note.apk() << std::endl;
  bits256 noteAPK = libzeth::hexadecimal_digest_to_bits256(note.apk());

  std::cout << "[ParseZethNote] Debug 2" << std::endl;
  bits64 noteValue = libzeth::hexadecimal_value_to_bits64(note.value());

  std::cout << "[ParseZethNote] Debug 3" << std::endl;
  bits256 noteRho = libzeth::hexadecimal_digest_to_bits256(note.rho());

  std::cout << "[ParseZethNote] Debug 4" << std::endl;
  bits384 noteRTrapR = libzeth::get_bits384_from_vector(libzeth::hexadecimal_str_to_binary_vector(note.trapr()));

  std::cout << "[ParseZethNote] Debug 5" << std::endl;

  return libzeth::ZethNote(
    noteAPK,
    noteValue,
    noteRho,
    noteRTrapR
  );
}

libzeth::JSInput ParseJSInput(const proverpkg::JSInput& input) {
  if (ZETH_MERKLE_TREE_DEPTH != input.merklenode_size()) {
    throw std::invalid_argument("Invalid merkle path length");
  }

  std::cout << "[ParseJSInput] Debug 1" << std::endl;
  libzeth::ZethNote inputNote = ParseZethNote(input.note());

  std::cout << "[ParseJSInput] Debug 2" << std::endl;
  size_t inputAddress = input.address();

  std::cout << "[ParseJSInput] Debug 3" << std::endl;
  bitsAddr inputAddressBits = libzeth::get_bitsAddr_from_vector(libzeth::address_bits_from_address(inputAddress, ZETH_MERKLE_TREE_DEPTH));

  std::cout << "[ParseJSInput] Debug 4" << std::endl;
  bits256 inputSpendingASK = libzeth::hexadecimal_digest_to_bits256(input.spendingask());

  std::cout << "[ParseJSInput] Debug 5" << std::endl;
  bits256 inputNullifier = libzeth::hexadecimal_digest_to_bits256(input.nullifier());

  std::cout << "[ParseJSInput] Debug 6" << std::endl;
  std::vector<libsnark::merkle_authentication_node> inputMerklePath;
  for(int i = 0; i < ZETH_MERKLE_TREE_DEPTH; i++) {
    libsnark::merkle_authentication_node mk_node = ParseMerkleNode(input.merklenode(i));
    inputMerklePath.push_back(mk_node);
  }
  std::cout << "[ParseJSInput] Debug 7" << std::endl;

  return libzeth::JSInput(
    inputMerklePath,
    inputAddress,
    inputAddressBits,
    inputNote,
    inputSpendingASK,
    inputNullifier
  );
}

HexadecimalPointBaseGroup1Affine FormatHexadecimalPointBaseGroup1Affine(libff::alt_bn128_G1 point) {
  libff::alt_bn128_G1 aff = point;
  aff.to_affine_coordinates();
  std::string xCoord = "0x" + HexStringFromLibsnarkBigint(aff.X.as_bigint());
  std::string yCoord = "0x" + HexStringFromLibsnarkBigint(aff.Y.as_bigint());
  
  HexadecimalPointBaseGroup1Affine res;
  res.set_xcoord(xCoord);
  res.set_ycoord(yCoord);

  return res;
}

HexadecimalPointBaseGroup2Affine FormatHexadecimalPointBaseGroup2Affine(libff::alt_bn128_G2 point) {
  libff::alt_bn128_G2 aff = point;
  aff.to_affine_coordinates();
  std::string xC1Coord = "0x" + HexStringFromLibsnarkBigint(aff.X.c1.as_bigint());
  std::string xC0Coord = "0x" + HexStringFromLibsnarkBigint(aff.X.c0.as_bigint());
  std::string yC1Coord = "0x" + HexStringFromLibsnarkBigint(aff.Y.c1.as_bigint());
  std::string yC0Coord = "0x" + HexStringFromLibsnarkBigint(aff.Y.c0.as_bigint());
  
  HexadecimalPointBaseGroup2Affine res;
  res.set_xc0coord(xC0Coord);
  res.set_xc1coord(xC1Coord);
  res.set_yc0coord(yC0Coord);
  res.set_yc1coord(yC1Coord);

  return res;
}

void PrepareProofResponse(extended_proof<ppT>& ext_proof, ExtendedProof* proof) {
  libsnark::r1cs_ppzksnark_proof<ppT> proofObj = ext_proof.get_proof();

  HexadecimalPointBaseGroup1Affine *a = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *a_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup2Affine *b = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *b_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *c = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *c_p = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *h = new HexadecimalPointBaseGroup1Affine();
  HexadecimalPointBaseGroup1Affine *k = new HexadecimalPointBaseGroup1Affine();

  a->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_A.g));
  a_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_A.h));
  b->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(proofObj.g_B.g)); // in G2
  b_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_B.h));
  c->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_C.g));
  c_p->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_C.h));
  h->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_H));
  k->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(proofObj.g_K));
  
  libsnark::r1cs_ppzksnark_primary_input<ppT> pubInputs = ext_proof.get_primary_input();
  std::stringstream ss;
  ss << "[";
  for (size_t i = 0; i < pubInputs.size(); ++i) {
    ss << "\"0x" << HexStringFromLibsnarkBigint(pubInputs[i].as_bigint()) << "\"";
    if ( i < pubInputs.size() - 1 ) {
        ss<< ", ";
    }
  }
  ss << "]";
  std::string inputs_json = ss.str();

  // Note on memory safety: set_allocated deleted the allocated objects
  // See: https://stackoverflow.com/questions/33960999/protobuf-will-set-allocated-delete-the-allocated-object
  // for more details
  proof->set_allocated_a(a);
  proof->set_allocated_ap(a_p);
  proof->set_allocated_b(b);
  proof->set_allocated_bp(b_p);
  proof->set_allocated_c(c);
  proof->set_allocated_cp(c_p);
  proof->set_allocated_h(h);
  proof->set_allocated_k(k);
  proof->set_inputs(inputs_json);
}

void PrepareVerifyingKeyResponse(VerificationKey* verificationKey) {
  HexadecimalPointBaseGroup2Affine *a = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *b = new HexadecimalPointBaseGroup1Affine(); // in G1
  HexadecimalPointBaseGroup2Affine *c = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup2Affine *g = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup1Affine *gb1 = new HexadecimalPointBaseGroup1Affine(); // in G1
  HexadecimalPointBaseGroup2Affine *gb2 = new HexadecimalPointBaseGroup2Affine(); // in G2
  HexadecimalPointBaseGroup2Affine *z = new HexadecimalPointBaseGroup2Affine(); // in G2

  libsnark::r1cs_ppzksnark_verification_key<ppT> vk = this->keypair.vk;
  a->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.alphaA_g2)); // in G2
  b->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(vk.alphaB_g1)); // in G1
  c->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.alphaC_g2)); // in G2
  g->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.gamma_g2)); // in G2
  gb1->CopyFrom(FormatHexadecimalPointBaseGroup1Affine(vk.gamma_beta_g1)); // in G1
  gb2->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.gamma_beta_g2)); // in G2
  z->CopyFrom(FormatHexadecimalPointBaseGroup2Affine(vk.rC_Z_g2)); // in G2
  
  libsnark::r1cs_ppzksnark_primary_input<ppT> pubInputs = ext_proof.get_primary_input();
  std::stringstream ss;
  ss <<  "[[" << outputPointG1AffineAsHex(vk.encoded_IC_query.first) << "]";

  for (size_t i = 1; i < icLength; ++i) {
    auto vkICi = outputPointG1AffineAsHex(vk.encoded_IC_query.rest.values[i - 1]);
    ss << ",[" <<  vkICi << "]";
  }
  ss << "]";
  std::string IC_json = ss.str();

  // Note on memory safety: set_allocated deleted the allocated objects
  // See: https://stackoverflow.com/questions/33960999/protobuf-will-set-allocated-delete-the-allocated-object
  // for more details
  verificationKey->set_allocated_a(a);
  verificationKey->set_allocated_b(b);
  verificationKey->set_allocated_c(c);
  verificationKey->set_allocated_g(g);
  verificationKey->set_allocated_gb1(gb1);
  verificationKey->set_allocated_gb2(gb2);
  verificationKey->set_allocated_z(z);
  verificationKey->set_ic(IC_json);
}

class ProverImpl final : public Prover::Service {
private:
  libzeth::CircuitWrapper<JSIns, JSOut> prover;
  libsnark::r1cs_ppzksnark_keypair<ppT> keypair; // Result of the setup

public:
  explicit ProverImpl(
    libzeth::CircuitWrapper<JSIns, JSOut>& prover,
    libsnark::r1cs_ppzksnark_keypair<ppT>& keypair
  ) : prover(prover), keypair(keypair) {}

  Status GetVerificationKey(
    ServerContext* context, 
    const EmptyMessage* request,
    VerificationKey* response
  ) override {
    std::cout << "[DEBUG] Preparing response" << std::endl;
    try {
      PrepareVerifyingKeyResponse(response);
    } catch (const std::exception& e) {
      std::cout << "[ERROR] " << e.what() << std::endl;
      return ::grpc::Status(::grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
    } catch (...) {
      std::cout << "[ERROR] In catch(...)"<< std::endl;
      return ::grpc::Status(::grpc::StatusCode::UNKNOWN, "");
    }

    return Status::OK;
  }

  Status Prove(
    ServerContext* context,
    const ProofInputs* proofInputs,
    ExtendedProof* proof
  ) override {
    std::cout << "[ACK] Received the request to generate a proof:" << std::endl;

    // Parse received message to feed to the prover
    try {
      std::cout << " === [DEBUG] 1 === " << std::endl;
      libzeth::bits256 root_bits = libzeth::hexadecimal_digest_to_bits256(proofInputs->root());
      std::cout << " === [DEBUG] 2 === " << std::endl;
      libzeth::bits64 vpub_in = libzeth::hexadecimal_value_to_bits64(proofInputs->inpubvalue());
      std::cout << " === [DEBUG] 3 === " << std::endl;
      libzeth::bits64 vpub_out = libzeth::hexadecimal_value_to_bits64(proofInputs->outpubvalue());

      std::cout << " === [DEBUG] 4 === " << std::endl;
      if (JSIns != proofInputs->jsinputs_size()) {
        throw std::invalid_argument("Invalid number of JS inputs");
      }
      if (JSOut != proofInputs->jsoutputs_size()) {
        throw std::invalid_argument("Invalid number of JS outputs");
      }

      std::cout << "[DEBUG] Process every inputs of the JoinSplit" << std::endl;
      std::array<libzeth::JSInput, JSIns> jsInputs;
      for(int i = 0; i < JSIns; i++) {
        proverpkg::JSInput receivedInput = proofInputs->jsinputs(i);
        libzeth::JSInput parsedInput = ParseJSInput(receivedInput);
        jsInputs[i] = parsedInput;
      }

      std::cout << "[DEBUG] Process every outputs of the JoinSplit" << std::endl;
      std::array<libzeth::ZethNote, JSOut> jsOutputs;
      for(int i = 0; i < JSOut; i++) {
        proverpkg::ZethNote receivedOutput = proofInputs->jsoutputs(i);
        libzeth::ZethNote parsedOutput = ParseZethNote(receivedOutput);
        jsOutputs[i] = parsedOutput;
      }

      std::cout << "[DEBUG] Data parsed successfully" << std::endl;

      //std::cout << "[DEBUG] Reading and loading the proving key from default file location" << std::endl;
      //boost::filesystem::path setup_dir = getPathToSetupDir();
      //boost::filesystem::path prov_key_raw("pk.raw");
      //boost::filesystem::path path_prov_key_raw = setup_dir / prov_key_raw;
      //libsnark::r1cs_ppzksnark_proving_key<ppT> pk = deserializeProvingKeyFromFile<ppT>(path_prov_key_raw);

      std::cout << "[DEBUG] Generating the proof" << std::endl;
      extended_proof<ppT> ext_proof = this->prover.prove(
        root_bits, 
        jsInputs, 
        jsOutputs, 
        vpub_in, 
        vpub_out, 
        this->keypair.pk
      );

      std::cout << "[DEBUG] Displaying the extended proof" << std::endl;
      ext_proof.dump_proof();
      ext_proof.dump_primary_inputs();

      std::cout << "[DEBUG] Preparing response" << std::endl;
      PrepareProofResponse(ext_proof, proof);

    } catch (const std::exception& e) {
      std::cout << "[ERROR] " << e.what() << std::endl;
      return ::grpc::Status(::grpc::StatusCode::INVALID_ARGUMENT, grpc::string(e.what()));
    } catch (...) {
      std::cout << "[ERROR] In catch(...)"<< std::endl;
      return ::grpc::Status(::grpc::StatusCode::UNKNOWN, "");
    }

    return Status::OK;
  }
};

void ServerStartMessage() {
  std::string copyright = "Copyright (c) 2015-2019 Clearmatics Technologies Ltd";
  std::string license = "SPDX-License-Identifier: LGPL-3.0+";
  std::string project = "R&D Department: PoC for Zerocash on Ethereum/Autonity";
  std::string version = "Version [TBD Use the zethConfig]";
  std::string warning = "**WARNING:** This code is a research-quality proof of concept, DO NOT USE in production!";

  std::cout << "\n=====================================================" << std::endl;
  std::cout << copyright << std::endl;
  std::cout << license << std::endl;
  std::cout << project << std::endl;
  std::cout << version << std::endl;
  std::cout << warning << std::endl;
  std::cout << "=====================================================\n" << std::endl;
}

void RunServer(
  libzeth::CircuitWrapper<JSIns, JSOut>& prover,
  libsnark::r1cs_ppzksnark_keypair<ppT>& keypair
) {
  // Listen for incoming connections on 0.0.0.0:50051
  std::string server_address("0.0.0.0:50051");

  ProverImpl service(prover, keypair);

  ServerBuilder builder;

  // Listen on the given address without any authentication mechanism.
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());

  // Register "service" as the instance through which we'll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  builder.RegisterService(&service);

  // Finally assemble the server.
  std::unique_ptr<Server> server(builder.BuildAndStart());
  std::cout << "[DEBUG] Server listening on " << server_address << std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  ServerStartMessage();
  server->Wait();
}

int main(int argc, char** argv) {
  // We inititalize the curve parameters here
  std::cout << "[DEBUG] Init params" << std::endl;
  ppT::init_public_params();

  std::cout << "[DEBUG] Run setup" << std::endl;
  libzeth::CircuitWrapper<JSIns, JSOut> prover;
  libsnark::r1cs_ppzksnark_keypair<ppT> keypair = prover.generate_trusted_setup();

  std::cout << "[DEBUG] Setup successful, starting the server..." << std::endl;
  RunServer(prover, keypair);
  return 0;
}
